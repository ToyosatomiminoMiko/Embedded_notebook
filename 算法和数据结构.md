# 算法和数据结构

## 前言

精通`Ctrl`+`C`/`V`:

原因:

0. 不会写,懒得写
1. 别人的算法比自己的更好

结果:

0. 省时,省力
1. 可以学习别人的算法

注意:

0. 在哪复制,在哪粘贴
1. 版权问题(License)

以上control+C/V六要素

## 算法

### 矩阵(Matrix)

生成0矩阵

```python
null_matrix = lambda x,y: [[0 for _ in range(x)] for _ in range(y)]
```

生成单位矩阵

```python
identity_matrix = lambda n: [[1 if i == j else 0 for j in range(n)] for i in range(n)]
```

任意维度转置

```python
'''
T=O(m*n)
S=O(m*n)
'''
transpose_xd = lambda matrix: list(map(list, zip(*matrix)))
```

### 前缀和&差分(Prefix & Difference)

两操互为逆运算

```python
def prefix_sum(array:List[int]) -> List[int]:
    """前缀和数组`O(n)`"""
    prefix_sum_array = [0]
    prefix = 0
    for i in range(len(array)):
        prefix += array[i]
        prefix_sum_array.append(prefix)
    return prefix_sum_array

def prefix_sum_query(prefix_sum_array:List[int], left: int, right: int) -> List[int]:
    """前缀和查询`O(1)`"""
    return prefix_sum_array[right] - prefix_sum_array[left - 1]
    
def difference(array:List[int]) -> List[int]:
    """差分数组"""
    difference_array = [array[0]]
    for i in range(len(array)-1):
        diff = array[i+1] - array[i]
        difference_array.append(diff)
    return difference_array

def test_deff_prefix():
    exp = [2, 5, 1, 9, 6]
    print(exp)
    print(prefix_sum(exp))
    print(difference(exp))
    print(difference(prefix_sum(exp)) == prefix_sum(difference(exp)))
```

### 原地算法

空间复杂度$O(1)$

### DP(动态规划)

## 数据结构

### 平衡二叉树

#### Red-Black Tree

节点要么是红色，要么是黑色

1. 根节点必须是黑色
2. 第一层到最后一层,每条路径的黑色节点数量必须相同
3. 红色节点不能连续出现
4. 叶子节点(即空节点/NIL节点)默认是黑色
5. 插入新节点时,默认设为红色,尽量不增加黑色节点数量

### 搜索

#### DFS

#### BFS
